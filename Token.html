<html>
<body style="margin: 0; touch-action: manipulation">
<svg height="100%" width="100%">
    <rect fill="#303030" width="100%" height="100%"/>
</svg>

<script>
document.querySelector("body").addEventListener("keydown", KeyDown)
document.querySelector("body").addEventListener("click", Click)
const svg = document.querySelector("svg")
const param = new URLSearchParams(window.location.search)

const Color = {
    Empty: 9,
    Token: 10,
    Border: 11,
    Back: "#14202A",
    Clue: ["#30383C", "#22A62C", "#2650DA", "#8018B2", "#E02020"]
}

const Layout = {
    width: 0,
    pad: 20,
    rect: [],
}

const Board = {
    width: 5,
    height: 5,
    finish: 0,

    table: [],
    rect: [],
    offset: [],
    clue: [],
    border: [],
    pattern: [],

    Init() {
        if (param.has("Width")) this.width = Number(param.get("Width"))
        if (param.has("Height")) this.height = Number(param.get("Height"))

        if (this.width < 2) this.width = 2
        if (this.height < 2) this.height = 2
        if (this.width == 2 && this.height == 2) {
            this.width = 3
            this.height = 3
        }

        let line = this.width + 1
        this.offset = [-line - 1, -line, -line + 1, -1, 1, line - 1, line, line + 1]
        this.table = []
        this.rect = []

        for (let y = 0, i = 0, k = this.height + 1; y <= k; y++) {
            for (let x = 0; x <= this.width; x++, i++) {
                if (x == 0 || y == 0 || y == k)
                    this.table.push(Color.Border)
                else {
                    this.rect.push(i)
                    this.table.push(Color.Empty)
                }
            }
        }

        // last cell's bottom right neighbour
        this.table.push(Color.Border)

        for (let n = 0; n <= 8; n++) { // pattern table
            let list = []
            for (let k = 0; k <= 8; k++) list.push(this.GetList(n, k))
            this.pattern.push(list)
        }

        let list = []
        if (param.has("Color")) for (i of param.get("Color").split("").map(Number))
            if (i > 0 && i < 5 && !list.includes(i)) list.push(i)
        if (list.length == 0) list = [1, 2, 3, 4]

        if (param.has("Table")) {
            let str = param.get("Table")
            this.clue = []
            this.finish = 0

            for (let i = 0; i < this.rect.length && i < str.length; i++) { // add clues
                let b = str.charAt(i)
                if (b != "X" && b != "A") {
                    let k = Number(str.charAt(i))
                    if (k > 0 && k < 5) {
                        let n = this.rect[i]
                        this.table[n] = k
                        this.clue.push({pos: n, value: k,
                            size: 0, token: 0, turn: 0, end: 0, list: [], iter: [], border: []})
                    }
                }
            }
        }
        else this.Create(list)
    },

    Create(list) {
        this.clue = []
        for (n of this.rect) this.table[n] = Color.Empty // clear table
        let size = Math.min(this.width, this.height)
        let value = -1

        while(1) {
            if (value == -1) { // add clue
                while(1) {
                    let i = this.rect[Math.floor(Math.random() * this.rect.length)]

                    if (this.FindClue(i) < 0) {
                        let k = list[Math.floor(Math.random() * list.length)]
                        this.clue.push({pos: i, value: k,
                                size: 0, token: 0, turn: 0, end: 0, list: [], iter: [], border: []})
                        this.table[i] = k
                        break
                    }
                }
            }
            else { // take clue
                let i = (value < 0 ? Math.floor(Math.random() * this.clue.length) : value)
                this.table[this.clue[i].pos] = Color.Empty
                this.clue.splice(i, 1)
            }

            if ((this.clue.length < 6 && (size > 4 || this.clue.length == 0)) || this.Span()) {
                value = -1 // add clue
                continue
            }

            if ((value = this.Rule()) >= 0) continue
            if ((value = this.Evaluate()) == 1) break
            value = value - 3
        }

        this.finish = this.clue.length
    },

    Evaluate() {
        this.GetBorder()
        let iter = this.clue[0]
        if (iter.value > iter.size) return 0 // first fail

        let total = 0
        let turn = 0
        let last = this.clue.length - 1
        iter.token = -1

        while (1) {
            if (iter.token < 0) { // update
                iter.token = iter.value - this.Count(iter.pos) // tokens to put

                if (iter.token == 0) {
                    if (turn == last) {
                        total++
                        if (total == 2) { // restore and return
                            for (let i = 0; i < this.clue.length; i++) {
                                let border = this.clue[i].border
                                for (let k = 0; k < border.length; k++) this.table[border[k]] = Color.Empty
                            }
                            return 2
                        }
                    }
                    else {
                        iter = this.clue[++turn] // next clue
                        iter.token = -1
                    }
                    continue
                }
                if (iter.token < 0 || iter.token > iter.size) { // check logic
                    iter = this.clue[--turn] // go back
                    continue
                }

                iter.list = this.pattern[iter.size][iter.token]
                iter.turn = 0
                iter.end = iter.list.length
            }
            else if (iter.token == 0) {
                if (turn == 0) return total
                iter = this.clue[--turn] // go back
                continue
            }
            else iter.turn++

            if (iter.turn == iter.end) {
                for (let k = 0; k < iter.border.length; k++) this.table[iter.border[k]] = Color.Empty // restore
                if (turn == 0) return total
                iter = this.clue[--turn] // go back
            }
            else {
                iter.iter = iter.list[iter.turn]

                for (let i = 0; i < iter.size; i++)
                    this.table[iter.border[i]] = iter.iter[i] // put token
                if (turn == last) {
                    total++
                    if (total == 2) { // restore and return
                        for (let i = 0; i < this.clue.length; i++) {
                            let border = this.clue[i].border
                            for (let k = 0; k < border.length; k++) this.table[border[k]] = Color.Empty
                        }
                        return 2
                    }
                }
                else {
                    iter = this.clue[++turn] // next clue
                    iter.token = -1
                }
            }
        }
    },

    GetList(n, k) {
        if (n < k || n == 0) return []
        if (k == 0) return [Array(n).fill(Color.Empty)]
        if (k == n) return [Array(n).fill(Color.Token)]
        return this.GetList(n - 1, k - 1).map(item => [...item, Color.Token]).concat(
            this.GetList(n - 1, k).map(item => [...item, Color.Empty]))
    },

    GetBorder() {
        this.border = []

        for (let i = 0; i < this.clue.length; i++) {
            let n = this.clue[i]
            n.border = []

            for (j = 0; j < 8; j++) {
                let k = n.pos + this.offset[j]

                if (this.table[k] == Color.Empty) {
                    if (!this.border.includes(k)) {
                        this.border.push(k)
                        n.border.push(k)
                    }
                }
            }

            n.size = n.border.length
        }
    },

    Rule() {
        for (let i = 0; i < this.clue.length; i++) {
            let n = this.clue[i].pos
            let total = 0

            for (let k = 0; k < 8; k++) // k of this.offset
                if (this.table[n + this.offset[k]] == Color.Empty) total++
            if (this.table[n] == total) return i // fill all empty
        }

        return -1
    },

    Span() {
        for (let y = 0, j = 0, line2 = false; y < this.height; y++, j += this.width) {
            let line = true // empty

            for (let x = 0, i = j; x < this.width; x++, i++) {
                if (this.table[this.rect[i]] < 9) { // clue
                    line = false
                    break
                }
            }

            if (line && line2) return true // two empty lines
            line2 = line
        }

        for (let x = 0, line2 = false; x < this.width; x++) {
            let line = true // empty

            for (let y = 0, i = x; y < this.height; y++, i += this.width) {
                if (this.table[this.rect[i]] < 9) { // clue
                    line = false
                    break
                }
            }

            if (line && line2) return true // two empty lines
            line2 = line
        }

        return false
    },

    FindClue(k) {
        for (let i = 0; i < this.clue.length; i++) if (this.clue[i].pos == k) return i
        return -1
    },

    Count(i) {
        let total = 0
        for (let k = 0; k < 8; k++) if (this.table[i + this.offset[k]] == Color.Token) total++
        return total
    },

    Value(i) { // clue k >= 0
        let k = this.table[i] & 15
        return (k < 9 ? k : -1)
    },

    Check(i) { // check clue around
        for (k of this.offset) {
            let j = i + k
            let n = this.table[j] & 15

            if (n < Color.Empty) { // is clue
                if (n == this.Count(j)) { // clue complete
                    if (!(this.table[j] & 16)) {
                        this.table[j] |= 16
                        this.finish--
                    }
                }
                else {
                    if (this.table[j] & 16) {
                        this.table[j] &= ~16
                        this.finish++
                    }
                }
            }
        }
    }
}

Board.Init()

Board.rect.forEach((n) => {
    let rect = document.createElement("img")
    rect.classList.add("Block")
    let k = Board.Value(n)
    if (k >= 0) rect.src = "Photo/" + String(k).padStart(2, '0') + ".png"
    else rect.src = "Photo/00.png"
    rect.style.position = "absolute"
    document.body.appendChild(rect)

    rect = document.createElement("img")
    rect.classList.add("Token")
    rect.src = "Photo/06.png"
    rect.style.position = "absolute"
    rect.style.display = ((Board.table[n] == Color.Token) ? "block" : "none")
    document.body.appendChild(rect)
});

Board.clue.forEach((n) => {
    const rect = document.createElement("img")
    rect.classList.add("Check")
    rect.src = "Photo/Check.png"
    rect.style.position = "absolute"
    rect.style.display = "none"
    document.body.appendChild(rect)
});

const block = document.getElementsByClassName("Block")
const token = document.getElementsByClassName("Token")
const check = document.getElementsByClassName("Check")

if (param.has("Table")) {
    Board.GetBorder()
    let str = param.get("Table")

    for (let i = 0; i < Board.rect.length && i < str.length; i++) // add tokens
        if (str.charAt(i) == "X")
            Board.table[Board.rect[i]] = Color.Token

    Board.clue.forEach((n, i) => {
        if (Board.table[n] == Board.Count(n)) {
            Board.table[n] |= 16 // clue complete
            check[i].style.display = "block"
        }
        else Board.finish++
    });
}

window.onresize = Resize
Resize()

function Resize() {
    let width = svg.clientWidth - Layout.pad * 2
    let height = svg.clientHeight - Layout.pad * 2

    if (width / height <= Board.width / Board.height)
        Layout.width = Math.floor(width / Board.width)
    else Layout.width = Math.floor(height / Board.height)

    Layout.rect = []

    a = {x: Math.floor((svg.clientWidth - Layout.width * Board.width) / 2),
        y: Math.floor((svg.clientHeight - Layout.width * Board.height) / 2)}

    for (let y = 0; y < Board.height; y++, a.y += Layout.width) {
        let b = {...a}

        for (let x = 0; x < Board.width; x++, b.x += Layout.width)
            Layout.rect.push({x: b.x, y: b.y})
    }

    [...block].forEach((n, i) => {
        n.style.width = Layout.width
        n.style.height = Layout.width
        n.style.left = Layout.rect[i].x
        n.style.top = Layout.rect[i].y
    });

    [...token].forEach((n, i) => {
        n.style.width = Layout.width
        n.style.height = Layout.width
        n.style.left = Layout.rect[i].x
        n.style.top = Layout.rect[i].y
    });

    for (let i = 0; i < Board.rect.length; i++) {
        let j = Board.rect[i]
        if (Board.Value(j) >= 0) { // clue
            const rect = check[Board.FindClue(j)]
            rect.style.width = Layout.width
            rect.style.height = Layout.width
            rect.style.position = "absolute"
            rect.style.left = Layout.rect[i].x
            rect.style.top = Layout.rect[i].y
        }
    }
}

function Marker(i) { // check clue around
    Board.offset.forEach((k) => {
        let j = i + k
        let n = Board.Value(j)

        if (n > 0) { // is clue
            if (n == Board.Count(j)) { // clue complete
                if (!(Board.table[j] & 16)) {
                    Board.table[j] |= 16
                    Board.finish--
                    check[Board.FindClue(j)].style.display = "block"
                }
            }
            else {
                if (Board.table[j] & 16) {
                    Board.table[j] &= ~16
                    Board.finish++
                    check[Board.FindClue(j)].style.display = "none"
                }
            }
        }
    });
}

function KeyDown(event) {
    if (event.key == "Escape") {
        Board.rect.forEach((i) => {
            let k = Board.table[i]
            if (k == Color.Token)
                Board.table[i] = Color.Empty
            else if (k != Color.Border)
                Board.table[i] &= ~16
        });

        [...token].forEach((n) => n.style.display = "none");
        [...check].forEach((n) => n.style.display = "none");
        Board.finish = Board.clue.length
    }
    else if (event.key == " ") {
        let str = ""
        const list = "012345678AX"
        Board.rect.forEach((n) => {str += list.charAt(Board.table[n] & ~16)})
        navigator.clipboard.writeText("Width=" + Board.width.toString() + "&Height=" + Board.height.toString() + "&Table=" + str)
    }
}

function Click(event) {
    for (let i = 0; i < Layout.rect.length; i++) {
        if (Layout.rect[i].y <= event.clientY && event.clientY < Layout.rect[i].y + Layout.width) {
            if (Layout.rect[i].x <= event.clientX && event.clientX < Layout.rect[i].x + Layout.width) {
                let j = Board.rect[i]

                if (Board.border.includes(j)) {
                    let k = Board.table[j]

                    if (k == Color.Empty || k == Color.Token) {
                        if (k == Color.Empty) {
                            Board.table[j] = Color.Token
                            token[i].style.display = "block"
                        }
                        else {
                            Board.table[j] = Color.Empty
                            token[i].style.display = "none"
                        }

                        Marker(j)

                        if (Board.finish == 0) {
                            var audio = new Audio("End.mp3")
                            audio.play()
                        }
                        else if (k == Color.Empty) {
                            var audio = new Audio("Click.wav")
                            audio.play()
                        }

                        return
                    }
                }
            }
        }
    }
}

</script>
</body>
</html>