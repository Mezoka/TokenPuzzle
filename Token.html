<html>
<body style="margin: 0; touch-action: manipulation">
<canvas></canvas>

<script>
document.querySelector("body").addEventListener("keydown", KeyDown)
const canvas = document.querySelector("canvas")
canvas.addEventListener("click", Click)
var context = canvas.getContext("2d")

const Color = {
    Empty: 9,
    Token: 10,
    Border: 11,
    Back: "#14202A",
    Clue: ["#30383C", "#22A62C", "#2650DA", "#8018B2", "#E02020"]
}

const Layout = {
    width: 0,
    half: 0,
    radius: 0,
    corner: 0,
    line: 0,
    pad: 0,
    rect: [],
}

const Board = {
    width: 5,
    height: 5,
    finish: 0,

    table: [],
    rect: [],
    offset: [],
    clue: [],
    border: [],
    pattern: [],

    Init() {
        const param = new URLSearchParams(window.location.search)
        if (param.has("Width")) this.width = Number(param.get("Width"))
        if (param.has("Height")) this.height = Number(param.get("Height"))

        if (this.width < 2) this.width = 2
        if (this.height < 2) this.height = 2
        if (this.width == 2 && this.height == 2) {
            this.width = 3
            this.height = 3
        }

        let line = this.width + 1
        this.offset = [-line - 1, -line, -line + 1, -1, 1, line - 1, line, line + 1]
        this.table = []
        this.rect = []

        for (let y = 0, i = 0, k = this.height + 1; y <= k; y++) {
            for (let x = 0; x <= this.width; x++, i++) {
                if (x == 0 || y == 0 || y == k)
                    this.table.push(Color.Border)
                else {
                    this.rect.push(i)
                    this.table.push(Color.Empty)
                }
            }
        }

        // last cell's bottom right neighbour
        this.table.push(Color.Border)

        for (let n = 0; n <= 8; n++) { // pattern table
            let list = []
            for (let k = 0; k <= 8; k++) list.push(this.GetList(n, k))
            this.pattern.push(list)
        }

        let list = []
        if (param.has("Color")) for (i of param.get("Color").split("").map(Number))
            if (i > 0 && i < 5 && !list.includes(i)) list.push(i)
        if (list.length == 0) list = [1, 2, 3, 4]

        if (param.has("Table")) {
            let str = param.get("Table")
            this.clue = []
            this.finish = 0

            for (let i = 0; i < this.rect.length && i < str.length; i++) { // add clues
                if (str.charAt(i) != "X") {
                    let k = Number(str.charAt(i))

                    if (k > 0 && k < 5) {
                        let n = this.rect[i]
                        this.table[n] = k
                        this.clue.push({pos: n, value: k,
                            size: 0, token: 0, turn: 0, end: 0, list: [], iter: [], border: []})
                    }
                }
            }

            this.GetBorder()

            for (let i = 0; i < this.rect.length && i < str.length; i++) // add tokens
                if (str.charAt(i) == "X")
                    this.table[this.rect[i]] = Color.Token

            for (n of this.clue) {
                let k = n.pos
                if (this.table[k] == this.Count(k)) this.table[k] |= 16 // clue complete
                else this.finish++
            }
        }
        else this.Create(list)
    },

    Create(list) {
        this.clue = []
        for (n of this.rect) this.table[n] = Color.Empty // clear table
        let size = Math.min(this.width, this.height)
        let value = -1

        while(1) {
            if (value == -1) { // add clue
                while(1) {
                    let i = this.rect[Math.floor(Math.random() * this.rect.length)]

                    if (!this.FindClue(i)) {
                        let k = list[Math.floor(Math.random() * list.length)]
                        this.clue.push({pos: i, value: k,
                                size: 0, token: 0, turn: 0, end: 0, list: [], iter: [], border: []})
                        this.table[i] = k
                        break
                    }
                }
            }
            else { // take clue
                let i = (value < 0 ? Math.floor(Math.random() * this.clue.length) : value)
                this.table[this.clue[i].pos] = Color.Empty
                this.clue.splice(i, 1)
            }

            if ((this.clue.length < 6 && (size > 4 || this.clue.length == 0)) || this.Span()) {
                value = -1 // add clue
                continue
            }

            if ((value = this.Rule()) >= 0) continue
            if ((value = this.Evaluate()) == 1) break
            value = value - 3
        }

        this.finish = this.clue.length
    },

    Evaluate() {
        this.GetBorder()
        let iter = this.clue[0]
        if (iter.value > iter.size) return 0 // first fail

        let total = 0
        let turn = 0
        let last = this.clue.length - 1
        iter.token = -1

        while (1) {
            if (iter.token < 0) { // update
                iter.token = iter.value - this.Count(iter.pos) // tokens to put

                if (iter.token == 0) {
                    if (turn == last) {
                        total++
                        if (total == 2) { // restore and return
                            for (let i = 0; i < this.clue.length; i++) {
                                let border = this.clue[i].border
                                for (let k = 0; k < border.length; k++) this.table[border[k]] = Color.Empty
                            }
                            return 2
                        }
                    }
                    else {
                        iter = this.clue[++turn] // next clue
                        iter.token = -1
                    }
                    continue
                }
                if (iter.token < 0 || iter.token > iter.size) { // check logic
                    iter = this.clue[--turn] // go back
                    continue
                }

                iter.list = this.pattern[iter.size][iter.token]
                iter.turn = 0
                iter.end = iter.list.length
            }
            else if (iter.token == 0) {
                if (turn == 0) return total
                iter = this.clue[--turn] // go back
                continue
            }
            else iter.turn++

            if (iter.turn == iter.end) {
                for (let k = 0; k < iter.border.length; k++) this.table[iter.border[k]] = Color.Empty // restore
                if (turn == 0) return total
                iter = this.clue[--turn] // go back
            }
            else {
                iter.iter = iter.list[iter.turn]

                for (let i = 0; i < iter.size; i++)
                    this.table[iter.border[i]] = iter.iter[i] // put token
                if (turn == last) {
                    total++
                    if (total == 2) { // restore and return
                        for (let i = 0; i < this.clue.length; i++) {
                            let border = this.clue[i].border
                            for (let k = 0; k < border.length; k++) this.table[border[k]] = Color.Empty
                        }
                        return 2
                    }
                }
                else {
                    iter = this.clue[++turn] // next clue
                    iter.token = -1
                }
            }
        }
    },

    GetList(n, k) {
        if (n < k || n == 0) return []
        if (k == 0) return [Array(n).fill(Color.Empty)]
        if (k == n) return [Array(n).fill(Color.Token)]
        return this.GetList(n - 1, k - 1).map(item => [...item, Color.Token]).concat(
            this.GetList(n - 1, k).map(item => [...item, Color.Empty]))
    },

    GetBorder() {
        this.border = []

        for (let i = 0; i < this.clue.length; i++) {
            let n = this.clue[i]
            n.border = []

            for (j = 0; j < 8; j++) {
                let k = n.pos + this.offset[j]

                if (this.table[k] == Color.Empty) {
                    if (!this.border.includes(k)) {
                        this.border.push(k)
                        n.border.push(k)
                    }
                }
            }

            n.size = n.border.length
        }
    },

    Rule() {
        for (let i = 0; i < this.clue.length; i++) {
            let n = this.clue[i].pos
            let total = 0
            for (let k = 0; k < 8; k++) // k of this.offset
                if (this.table[n + this.offset[k]] == Color.Empty) total++
            if (this.table[n] == total) return i // fill all empty
        }

        return -1
    },

    Span() {
        for (let y = 0, j = 0, line2 = false; y < this.height; y++, j += this.width) {
            let line = true // empty

            for (let x = 0, i = j; x < this.width; x++, i++) {
                if (this.table[this.rect[i]] < 9) { // clue
                    line = false
                    break
                }
            }

            if (line && line2) return true // two empty lines
            line2 = line
        }

        for (let x = 0, line2 = false; x < this.width; x++) {
            let line = true // empty

            for (let y = 0, i = x; y < this.height; y++, i += this.width) {
                if (this.table[this.rect[i]] < 9) { // clue
                    line = false
                    break
                }
            }

            if (line && line2) return true // two empty lines
            line2 = line
        }

        return false
    },

    FindClue(k) {
        for (let i = 0; i < this.clue.length; i++) if (this.clue[i].pos == k) return true
        return false
    },

    Count(i) {
        let total = 0
        for (let k = 0; k < 8; k++) if (this.table[i + this.offset[k]] == Color.Token) total++
        return total
    },

    Check(i) { // check clue around
        for (k of this.offset) {
            let j = i + k
            let n = this.table[j] & 15

            if (n < Color.Empty) { // is clue
                if (n == this.Count(j)) { // clue complete
                    if (!(this.table[j] & 16)) {
                        this.table[j] |= 16
                        this.finish--
                    }
                }
                else {
                    if (this.table[j] & 16) {
                        this.table[j] &= ~16
                        this.finish++
                    }
                }
            }
        }
    }
}

Board.Init()
window.onresize = Resize
Resize()

function Resize() {
    canvas.width = window.innerWidth
    canvas.height = window.innerHeight

    let width = Board.width + 1 + (Board.width - 1) * 0.08
    let height = Board.height + 1 + (Board.height - 1) * 0.08

    if (canvas.width / canvas.height <= width / height)
        Layout.width = canvas.width / width
    else Layout.width = canvas.height / height

    Layout.pad = Math.floor(Layout.width * 0.08)
    if (Layout.pad < 2) Layout.pad = 2

    Layout.width = Math.floor(Layout.width)
    Layout.half = Layout.width / 2
    Layout.radius = Layout.width * 0.4
    Layout.corner = Layout.width * 0.05
    Layout.line = Layout.width * 0.06

    Layout.rect = []
    a = {x: Math.floor((canvas.width - Board.width * Layout.width - (Board.width - 1) * Layout.pad) / 2),
        y: Math.floor((canvas.height - Board.height * Layout.width - (Board.height - 1) * Layout.pad) / 2)}

    for (let y = 0, i = 0; y < Board.height; y++, a.y += Layout.width + Layout.pad) {
        let b = {...a}

        for (let x = 0; x < Board.width; x++, i++, b.x += Layout.width + Layout.pad) {
            Layout.rect.push({x: b.x, y: b.y})
        }
    }

    Draw()
}

function Draw() {
    context.fillStyle = Color.Back
    context.fillRect(0, 0, canvas.width, canvas.height)

    for (let i = 0; i < Board.rect.length; i++) {
        let k2 = Board.table[Board.rect[i]]
        let k = k2 & 15

        context.beginPath();
        context.roundRect(Layout.rect[i].x, Layout.rect[i].y, Layout.width, Layout.width, Layout.corner)
        context.fillStyle = Color.Clue[(k > 0 && k < 5 ? k : 0)]
        context.fill()

        if (k == Color.Token) {
            context.beginPath()
            context.arc(Layout.rect[i].x + Layout.half, Layout.rect[i].y + Layout.half, Layout.radius, 0, 2 * Math.PI)
            context.fillStyle = "#F0901E"
            context.fill()
            context.lineWidth = Layout.line
            context.strokeStyle = "black"
            context.stroke()
        }

        if (k2 & 16) { // clue complete
            context.beginPath()
            context.moveTo(Layout.rect[i].x + Layout.width * 0.15, Layout.rect[i].y + Layout.width * 0.15)
            context.lineTo(Layout.rect[i].x + Layout.width * 0.85, Layout.rect[i].y + Layout.width * 0.85)
            context.moveTo(Layout.rect[i].x + Layout.width * 0.85, Layout.rect[i].y + Layout.width * 0.15)
            context.lineTo(Layout.rect[i].x + Layout.width * 0.15, Layout.rect[i].y + Layout.width * 0.85)
            context.lineWidth = Layout.line
            context.strokeStyle = "black"
            context.stroke()
        }
    }
}

function KeyDown(event) {
    if (event.key == "Escape") {
        for (i of Board.rect) {
            let k = Board.table[i]
            if (k == Color.Token)
                Board.table[i] = Color.Empty
            else if (k != Color.Border)
                Board.table[i] &= ~16
        }

        Board.finish = Board.clue.length
        Draw()
    }
    if (event.key == " ") {
        let str = ""
        const list = "012345678AX"
        for (n of Board.rect) str += list.charAt(Board.table[n] & ~16)
        navigator.clipboard.writeText("Width=" + Board.width.toString() + "&Height=" + Board.height.toString() + "&Table=" + str)
    }
}

function Click(event) {
    for (let i = 0; i < Layout.rect.length; i++) {
        if (Layout.rect[i].y <= event.clientY && event.clientY < Layout.rect[i].y + Layout.width) {
            if (Layout.rect[i].x <= event.clientX && event.clientX < Layout.rect[i].x + Layout.width) {
                let j = Board.rect[i]

                if (Board.border.includes(j)) {
                    let k = Board.table[j]

                    if (k == Color.Empty || k == Color.Token) {
                        Board.table[j] = (k == Color.Empty ? Color.Token : Color.Empty)
                        Board.Check(j)

                        if (Board.finish == 0) {
                            var audio = new Audio("End.mp3")
                            audio.play()
                        }
                        else if (k == Color.Empty) {
                            var audio = new Audio("Click.wav")
                            audio.play()
                        }

                        Draw()
                        return
                    }
                }
            }
        }
    }
}

</script>
</body>
</html>